<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue指令</title>
      <link href="2021/02/28/Vue%E6%8C%87%E4%BB%A4/"/>
      <url>2021/02/28/Vue%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h1><p>作用是定义他的元素或者组件只会渲染一次，包括元素或者组件的所有节点</p><p>如果每一次组件的内容都一样，可以在组件上使用v-once指令，这样组件在第一次渲染的时候，会缓存到内存，如果以后切换组件，会直接从内存中取出该组件，提高效率。所以页面中大多是静态内容，想进一步优化性能的时候，可能会用到v-once。</p><pre><code> &lt;div v-once&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</code></pre><p>v-on后面不需跟任何表达式</p><h1 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h1><p>某些情况下，我们从服务器请求到的数据本身就是一个HTML代码（标签），如果我们直接通过 {{}}或者v-text来输出，会将HTML代码也一起输出。但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容1、该指令后面往往会跟上一个string类型2、会将string的html解析出来并且进行渲染```<div id='app'>        <h2></h2><br>        <h2 v-html='link'></h2><br>    </div><br>    <script src=../vue.js></script><br>    <script><br>        const vm = new Vue({<br>            el: '#app',<br>            data: {<br>                link: <code>&lt;a href=&#39;http://www.baidu.com&#39;&gt;百度一下&lt;/a&gt;</code><br>            },<br>            methods: {},<br>        })<br>    </script></p><pre><code></code></pre><p>执行结果是：<br>  <a href='http://www.baidu.com'>百度一下</a><br>  百度一下</p><pre><code># v-text填充纯文本，比插值表达式更简洁，编译后再显示结果，不会闪烁，插值表达式和v-text都可以使用表达式进行运算v-text通常情况下，接受一个string类型</code></pre> <h2 v-text='link'></h2>```<h1 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h1><p>v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法</p><pre><code> &lt;div id=&#39;app&#39;&gt;     &lt;h2&gt;&#123;&#123;link&#125;&#125;&lt;/h2&gt;     &lt;h2 v-pre&gt;&#123;&#123;link&#125;&#125;&lt;/h2&gt;    &lt;/div&gt;    &lt;script src=../vue.js&gt;&lt;/script&gt;    &lt;script&gt;        const vm = new Vue(&#123;            el: &#39;#app&#39;,            data: &#123;                link: `giao`            &#125;,            methods: &#123;&#125;,        &#125;)    &lt;/script&gt;</code></pre><p>第一个h2元素中的内容会被编译解析出来对应的内容</p><p>第二个h2元素中会直接显示</p><h1 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h1><p>HTML解析都是从上往下执行，如果js卡住的话，就会显示原来的。</p><p>在vue解析之前，div中有个属性v-cloak，解析之后，v-cloak就消失了</p><p>其实这个指令是可以用到任何一个 Vuejs 的组件当中的，比如这样 <code>&lt;componentv-cloak&gt;&lt;/component&gt;</code></p><pre><code>    &lt;style&gt;        [v-cloak] &#123;            display: none;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&#39;app&#39;&gt;        &lt;h2 v-cloak&gt;&#123;&#123;link&#125;&#125;&lt;/h2&gt;    &lt;/div&gt;    &lt;script src=../vue.js&gt;&lt;/script&gt;    &lt;script&gt;        setTimeout(() =&gt; &#123;            const vm = new Vue(&#123;                el: &#39;#app&#39;,                data: &#123;                    link: `giao`                &#125;,                methods: &#123;&#125;,            &#125;)        &#125;, 1000);    &lt;/script&gt;</code></pre><h1 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h1><p>v-bind是动态绑定属性的指令</p><p>比如图片的链接src、网站的链接href、动态绑定一些类、样式等等，通过Vue实例中的data绑定元素的src和href</p><p>语法糖形式是  ：</p><h2 id="绑定class"><a href="#绑定class" class="headerlink" title="绑定class"></a>绑定class</h2><p>很多时候，我们希望动态的来切换class，比如：</p><p>当数据为某个状态时，字体显示红色。</p><p>当数据另一个状态时，字体显示黑色。</p><h3 id="绑定class的对象语法（常用）"><a href="#绑定class的对象语法（常用）" class="headerlink" title="绑定class的对象语法（常用）"></a>绑定class的对象语法（常用）</h3><p>对象语法的含义是  :  class后面跟的是一个对象。对象里面如果是字符串，就要加双引号，如果不加双引号，就被当成变量</p><pre><code>用法一：直接通过&#123;&#125;绑定一个类&lt;h2 :class=&quot;&#123;&#39;active&#39;: isActive&#125;&quot;&gt;Hello World&lt;/h2&gt;用法二：也可以通过判断，传入多个值&lt;h2 :class=&quot;&#123;&#39;active&#39;: isActive, &#39;line&#39;: isLine&#125;&quot;&gt;Hello World&lt;/h2&gt;用法三：和普通的类同时存在，并不冲突注：如果isActive和isLine都为true，那么会有title/active/line三个类&lt;h2 class=&quot;title&quot; :class=&quot;&#123;&#39;active&#39;: isActive, &#39;line&#39;: isLine&#125;&quot;&gt;Hello World&lt;/h2&gt;用法四：如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性&lt;h2 class=&quot;title&quot; :class=&quot;classes&quot;&gt;Hello World&lt;/h2&gt;</code></pre><h3 id="绑定class的数组语法"><a href="#绑定class的数组语法" class="headerlink" title="绑定class的数组语法"></a>绑定class的数组语法</h3><p>数组语法的含义是:class后面跟的是一个数组。</p><pre><code>用法一：直接通过&#123;&#125;绑定一个类&lt;h2 :class=&quot;[&#39;active&#39;]&quot;&gt;Hello World&lt;/h2&gt;用法二：也可以传入多个值&lt;h2 :class=“[‘active’, &#39;line&#39;]&quot;&gt;Hello World&lt;/h2&gt;用法三：和普通的类同时存在，并不冲突注：会有title/active/line三个类&lt;h2 class=&quot;title&quot; :class=“[‘active’, &#39;line&#39;]&quot;&gt;Hello World&lt;/h2&gt;用法四：如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性&lt;h2 class=&quot;title&quot; :class=&quot;classes&quot;&gt;Hello World&lt;/h2&gt;</code></pre><h2 id="绑定style"><a href="#绑定style" class="headerlink" title="绑定style"></a>绑定style</h2><p>可以利用v-bind:style来绑定一些CSS内联样式。在写CSS属性名的时候，比如font-size</p><p>我们可以使用驼峰式 (camelCase) fontSize </p><p>或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’</p><p>组件化开发时，有些不同，</p><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><pre><code>:style=&quot;&#123;color: currentColor, fontSize: fontSize + &#39;px&#39;&#125;&quot;style后面跟的是一个对象类型对象的key是CSS属性名称对象的value是具体赋的值，值可以来自于data中的属性</code></pre><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><pre><code>&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;style后面跟的是一个数组类型多个值以，分割即可</code></pre><h1 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h1><p>作用是绑定事件监听器，，语法糖是@</p><h2 id="v-on参数"><a href="#v-on参数" class="headerlink" title="v-on参数"></a>v-on参数</h2><p>当通过methods中定义方法，以供@click调用时，需要<strong>注意参数问题</strong>：</p><p><strong>情况一</strong>：如果该方法不需要额外参数，那么方法后的()可以不添加。</p><p><strong>情况二</strong>：如果方法本身中有一个参数，调用时不加括号，那么会默认将原生事件event参数传递进去，</p><p>加了括号但是里面没传参数，就会返回undefined，加括号传参数，会返回传的参数</p><p><strong>情况三</strong>：如果需要同时传入某个参数，如果传基本数据类型时，浏览器会自动转化参数（非变量），如果传类似标志符时，就会被当成变量，而在实例找不到这个变量，就会报错，，需要event时，可以通过$event传入事件（一般写最后）。</p><pre><code> &lt;div id=&#39;app&#39;&gt;        &lt;button @click=&#39;btn1Click()&#39;&gt;无参按钮1&lt;/button&gt;        &lt;button @click=&#39;btn1Click&#39;&gt;无参按钮2&lt;/button&gt;        &lt;!-- 在事件定义时，写函数省略了小括号，但是方法本身需要一个参数的 --&gt;        &lt;hr&gt;        &lt;button @click=&#39;btn2Click()&#39;&gt;有参按钮1&lt;/button&gt;        &lt;button @click=&#39;btn2Click&#39;&gt;有参按钮2&lt;/button&gt;        &lt;button @click=&#39;btn2Click(123123123)&#39;&gt;有参按钮3&lt;/button&gt;        &lt;hr&gt;        &lt;button @click=&#39;btn3Click($event,&quot;giao&quot;)&#39;&gt;多参按钮&lt;/button&gt;    &lt;/div&gt;    &lt;script src=../vue.js&gt;&lt;/script&gt;    &lt;script&gt;        const vm = new Vue(&#123;            el: &#39;#app&#39;,            data: &#123;                msg: 0,                event: 11            &#125;,            methods: &#123;                btn1Click() &#123;                    console.log(&#39;我是无参的&#39;);                &#125;,                btn2Click(event) &#123;                    console.log(&#39;--------&#39;, event);                &#125;,                btn3Click(abc, event) &#123;                    console.log(abc, event);                &#125;            &#125;,        &#125;)</code></pre><h2 id="v-on修饰符"><a href="#v-on修饰符" class="headerlink" title="v-on修饰符"></a>v-on修饰符</h2><p>在某些情况下，我们拿到event的目的可能是进行一些事件处理。</p><p>Vue提供了修饰符来帮助我们方便的处理一些事件：</p><p>.stop - 调用 event.stopPropagation()。    <strong>停止冒泡</strong></p><p>.prevent - 调用 event.preventDefault()。    <strong>阻止默认行为</strong></p><p>.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。</p><p>.native - 监听组件根元素的原生事件。</p><p>.once - 只触发一次回调。</p><h1 id="v-if、v-else-if、v-else"><a href="#v-if、v-else-if、v-else" class="headerlink" title="v-if、v-else-if、v-else"></a>v-if、v-else-if、v-else</h1><p>这三个指令与JavaScript的条件语句if、else、else if类似。</p><p>Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件</p><p>v-if的原理：</p><p>v-if后面的条件为false时，对应的元素以及其子元素不会渲染。</p><p>也就是根本没有不会有对应的标签出现在DOM中。</p><pre><code>  &lt;div id=&#39;app&#39;&gt;        &lt;span v-if=&#39;isUser&#39;&gt;            &lt;!-- 点击之后使id为username的标签处于聚焦状态 --&gt;            &lt;label for=&quot;usernam&quot;&gt;用户账号&lt;/label&gt;            &lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;用户账号&quot; key=&#39;username&#39;&gt;        &lt;/span&gt;        &lt;span v-else=&#39;&#39;&gt;            &lt;label for=&quot;username&quot;&gt;用户邮箱&lt;/label&gt;            &lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;用户邮箱&quot; key=&#39;email&#39;&gt;        &lt;/span&gt;        &lt;button @click=&#39;isUser=!isUser&#39;&gt;切换类型&lt;/button&gt;    &lt;/div&gt;    &lt;script src=../../vue.js&gt;&lt;/script&gt;    &lt;script&gt;        const vm = new Vue(&#123;            el: &#39;#app&#39;,            data: &#123;                isUser: true            &#125;,            methods: &#123;            &#125;,        &#125;)    &lt;/script&gt;</code></pre><pre><code>小问题：如果我们在有输入内容的情况下，切换了类型，我们会发现文字依然显示之前的输入的内容。但是按道理讲，我们应该切换到另外一个input元素中了。在另一个input元素中，我们并没有输入内容。为什么会出现这个问题呢？这是因为Vue在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。在上面的案例中，Vue内部会发现原来的input元素不再使用，直接作为else中的input来使用了。解决方案：如果我们不希望Vue出现类似重复利用的问题，可以给对应的input添加key并且我们需要保证key的不同</code></pre><h1 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h1><p>v-for的语法类似于JavaScript中的for循环。</p><p>格式如下：item in items的形式。</p><p>我们来看一个简单的案例：</p><p>如果在遍历的过程中不需要使用索引值</p><p>v-for=”movie in movies”</p><p>依次从movies中取出movie，并且在元素的内容中，我们可以使用Mustache语法，来使用movie</p><p>如果在遍历的过程中，我们需要拿到元素在数组中的索引值呢？</p><p>语法格式：v-for=(item, index) in items</p><p>其中的index就代表了取出的item在原数组的索引值。</p><pre><code> &lt;div id=&#39;app&#39;&gt;        &lt;ul&gt;            &lt;!-- 遍历数组 --&gt;            &lt;li v-for=&#39;(item,index) in arrayName&#39;&gt;&#123;&#123;index+1&#125;&#125;&#123;&#123;item&#125;&#125;&lt;/li&gt;            &lt;hr&gt;            &lt;!-- 遍历对象 --&gt;            &lt;ul&gt;                &lt;li v-for=&#39;(value,key,index) in objName&#39;&gt;&#123;&#123;value&#125;&#125;---&#123;&#123;key&#125;&#125;----&#123;&#123;index+1&#125;&#125;&lt;/li&gt;            &lt;/ul&gt;            &lt;hr&gt;            &lt;ul&gt;                &lt;li v-for=&#39;item in keyArray&#39; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;            &lt;/ul&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script src=../vue.js&gt;&lt;/script&gt;    &lt;script&gt;        const vm = new Vue(&#123;            el: &#39;#app&#39;,            data: &#123;                arrayName: [&#39;唐人街探案3&#39;, &#39;你好，李焕英&#39;, &#39;复仇者联盟4&#39;, &#39;流浪地球&#39;],                objName: &#123;                    name: &#39;威哥&#39;,                    age: 21,                    waihao: &#39;666&#39;                &#125;,                keyArray: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;]            &#125;,            methods: &#123;&#125;,        &#125;)    &lt;/script&gt;</code></pre><p><img src="images%5Cv-for%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86.jpg"></p><p><strong>key的作用主要是为了高效的更新虚拟OM。要与值一一对应才有用</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
